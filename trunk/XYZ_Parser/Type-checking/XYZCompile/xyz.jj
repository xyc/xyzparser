/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. xyz.jj */
/*@egen*//* Copyright (c) 2006, Sun Microsystems, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Sun Microsystems, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
 
/* Options. */
options {
              
                
                          
                  
}
 
PARSER_BEGIN(XYZParser)

import java.io.*;
import java.util.*;

/** XYZParser. */
public class XYZParser/*@bgen(jjtree)*/implements XYZParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTXYZParserState jjtree = new JJTXYZParserState();

/*@egen*/

  /** Main entry point. */
  public static void main(String args[]) throws ParseException {
	try{
			
  	 	File file = new File("test.xyz");
  		FileInputStream stream = new FileInputStream(file);
        XYZParser parser = new XYZParser(stream);
        
        SimpleNode n = parser.parse();
      	n.dump("");
        
        TestVisitor v = new TestVisitor();
        n.jjtAccept(v, null);
        System.out.println("StatementCount:"+v.getStatementCount());
        System.out.println("TotalWeight:"+v.getTotalWeight());
        
        //parser.lexicalAnalyze();
        stream.close();
        
        /*
        stream = new FileInputStream(file);
        parser.ReInit(stream);
        parser.outputStatisticsFile();*/
	}catch(Exception e){
	  	e.printStackTrace();
	  	}
	  }
}

PARSER_END(XYZParser)

/* WHITE SPACE */
SKIP :
{
" "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* OPERATIONS */
TOKEN :
{
<NOT:"!">
| <ASSIGN:"=">
| <AND:"&&">
| <LT:"<">
| <PLUS:"+">
| <MINUS:"-">
| <MUL:"*">
//| <OPER:(<NOT>|<ASSIGN>|<AND>|<PLUS>|<LT>|<MINUS>|<MUL>)>
}

/* KEY WORDS */
TOKEN :
{
<PUBLIC:"public">
| <CLASS:"class">
| <EXTENDS:"extends">
| <STATIC:"static">
| <VOID:"void">
| <MAIN:"main">
| <STRING:"String">
| <IF:"if">
| <ELSE:"else">
| <DO:"do">
| <WHILE:"while">
| <NEW:"new">
| <LENGTH:"length">
| <PRINT:"System.out.println">
| <INT:"int">
| <BOOLEAN:"boolean">
| <TRUE:"true">
| <FALSE:"false">
| <THIS:"this">
| <RETURN:"return">
| <DOUBLE:"double">
//| <KEYWORD:(<PUBLIC>|<CLASS>|<EXTENDS>|<STATIC>|<VOID>|<MAIN>|<STRING>|<IF>|<ELSE>|<DO>|<DOUBLE>
//		   |<WHILE>|<NEW>|<LENGTH>|<PRINT>|<INT>|<BOOLEAN>|<TRUE>|<FALSE>|<THIS>|<RETURN>)>		//warning!
}


/* SEPARATORS  */
TOKEN : {
<LBRACE: "{">
| <RBRACE: "}">
| <LBRACK:"[">
| <RBRACK:"]">
| <LPAREN:"(">
| <RPAREN:")">
| <COMMA:",">
| <SEMI:";">
| <DOT:".">
//| <SIGN:(<LBRACE>|<RBRACE>|<LBRACK>|<RBRACK>|<LPAREN>|<RPAREN>|<COMMA>|<SEMI>|<DOT>)>
}

/* LITERALS */
TOKEN :
{
<INTLITERAL:(["0" - "9"])+>
| <REALLITERAL:((["0"-"9"])+"."(["0"-"9"])*)|((["0"-"9"])*"."(["0"-"9"])+)>
}


/*IDENTIFIERS*/
TOKEN :
{
<ID: (["a"-"z","A"-"Z"])(["a"-"z","A"-"Z","0"-"9","_"])*>
}

/* COMMENTS */
TOKEN:{
	<#ONE_LINE_COMMENT: "//"(~["\n", "\r"])*("\n"|"\r" |"\r\n")>
|	<#LINES_COMMENT: "/*"((~["*"])|("*"(~["/"])))*"*/">
|	<#FORMAL_COMMENT: "/**"((~["*"])|("*"(~["/"])))*"*/">
//|	<COMMENT:(<ONE_LINE_COMMENT>|<LINES_COMMENT>|<FORMAL_COMMENT>)>
}

/** Root production. */
SimpleNode parse()	      :
{/*@bgen(jjtree) Root */
  Root jjtn000 = new Root(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Root */
        try {
/*@egen*/
	Program()
	//(<INTLITERAL>|<REALLITERAL>|<ID>|<KEYWORD>|<SIGN>|<OPER>|<COMMENT>)*
	<EOF>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Program() : {}
{/*@bgen(jjtree) Program */
{
  Program jjtn001 = new Program(JJTPROGRAM);
  boolean jjtc001 = true;
  jjtree.openNodeScope(jjtn001);
}
try {
/*@egen*/
(
	MainClass()
	(ClassDecl())*
)/*@bgen(jjtree)*/
} catch (Throwable jjte001) {
  if (jjtc001) {
    jjtree.clearNodeScope(jjtn001);
    jjtc001 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte001 instanceof RuntimeException) {
    throw (RuntimeException)jjte001;
  }
  if (jjte001 instanceof ParseException) {
    throw (ParseException)jjte001;
  }
  throw (Error)jjte001;
} finally {
  if (jjtc001) {
    jjtree.closeNodeScope(jjtn001, true);
  }
}
/*@egen*/         
}

void MainClass()           : {/*@bgen(jjtree) MainClass */
                              MainClass jjtn000 = new MainClass(JJTMAINCLASS);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) MainClass */
        try {
/*@egen*/
	<CLASS>
	t = <ID>
	<LBRACE>
	<PUBLIC><STATIC><VOID><MAIN>
	<LPAREN>
	<STRING><LBRACK><RBRACK><ID>
	<RPAREN>
	<LBRACE>
	(Statement())*
	<RBRACE>
	<RBRACE>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/

{jjtn000.setText("class " + t.image);}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ClassDecl()           : {/*@bgen(jjtree) ClassDecl */
                              ClassDecl jjtn000 = new ClassDecl(JJTCLASSDECL);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) ClassDecl */
        try {
/*@egen*/
	<CLASS>
	t = <ID>
	(<EXTENDS><ID>)?
	<LBRACE>
	(Body())*
	<RBRACE>/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
}
/*@egen*/

{jjtn000.setText("class " + t.image);}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}

void Body() : {}
{
	VarDecl()
	|MethodDecl()
}


void Statement()      : {}
{
	//LOOKAHEAD(6)<IF><LPAREN>Exp()<RPAREN>Statement()<ELSE>Statement()
	//|<IF><LPAREN>Exp()<RPAREN>Statement()
	IfStatement()
	|WhileStatement()
	|StatementBlock()
	|SingleStatement()
	//|<PRINT><LPAREN>Exp()<RPAREN><SEMI>
	//|LOOKAHEAD(2)<ID><ASSIGN>Exp()<SEMI>
	//|<ID><LBRACK>Exp()<RBRACK><ASSIGN>Exp()<SEMI>
	//|<WHILE><LPAREN>Exp()<RPAREN>Statement()
	//|<DO>Statement()<WHILE><LPAREN>Exp()<RPAREN>
}

void IfStatement()                 : {/*@bgen(jjtree) IfStatementNode */
  IfStatementNode jjtn000 = new IfStatementNode(JJTIFSTATEMENTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IfStatementNode */
        try {
/*@egen*/
	LOOKAHEAD(6)<IF><LPAREN>Exp()<RPAREN>Statement()<ELSE>Statement()
	|<IF><LPAREN>Exp()<RPAREN>Statement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void WhileStatement()                    : {/*@bgen(jjtree) WhileStatementNode */
  WhileStatementNode jjtn000 = new WhileStatementNode(JJTWHILESTATEMENTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileStatementNode */
        try {
/*@egen*/
	<WHILE><LPAREN>Exp()<RPAREN>Statement()
	|<DO>Statement()<WHILE><LPAREN>Exp()<RPAREN><SEMI>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void StatementBlock() : {}
{
	<LBRACE> (Statement())* <RBRACE>
}

void SingleStatement()                     : {/*@bgen(jjtree) SingleStatementNode */
  SingleStatementNode jjtn000 = new SingleStatementNode(JJTSINGLESTATEMENTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SingleStatementNode */
        try {
/*@egen*/
	PrintStatement()|AssignStatement()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void PrintStatement() : {}
{
<PRINT><LPAREN>Exp()<RPAREN><SEMI>
}

void AssignStatement() : {}
{
LOOKAHEAD(2)<ID><ASSIGN>Exp()<SEMI>
|<ID><LBRACK>Exp()<RBRACK><ASSIGN>Exp()<SEMI>
}

void VarDecl()             : {/*@bgen(jjtree) VarDeclNode */
                               VarDeclNode jjtn000 = new VarDeclNode(JJTVARDECLNODE);
                               boolean jjtc000 = true;
                               jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; String type;}
{/*@bgen(jjtree) VarDeclNode */
        try {
/*@egen*/
	type = Type()
	t=<ID><SEMI>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{jjtn000.setText(type + " " + t.image);	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void MethodDecl()            : {/*@bgen(jjtree) MethodNode */
                                MethodNode jjtn000 = new MethodNode(JJTMETHODNODE);
                                boolean jjtc000 = true;
                                jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String type;}
{/*@bgen(jjtree) MethodNode */
        try {
/*@egen*/
	<PUBLIC>
	type = Type()
	t = <ID>
	<LPAREN>FormalList()<RPAREN>
	<LBRACE>
	(MethodBody())*
	ReturnStatement()
	<RBRACE>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{jjtn000.setText(type + " " + t.image);}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void MethodBody() : {}
{
	LOOKAHEAD(VarDecl())VarDecl()
	|Statement()
}

void FormalList()                : {/*@bgen(jjtree) FormalListNode */
                                    FormalListNode jjtn000 = new FormalListNode(JJTFORMALLISTNODE);
                                    boolean jjtc000 = true;
                                    jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;String type;}
{/*@bgen(jjtree) FormalListNode */
        try {
/*@egen*/
	(
	type = Type()
	t= <ID>
	(FormalRest())*
	{jjtn000.setText(type + " " + t.image);}
	)?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void FormalRest()                : {/*@bgen(jjtree) FormalRestNode */
                                    FormalRestNode jjtn000 = new FormalRestNode(JJTFORMALRESTNODE);
                                    boolean jjtc000 = true;
                                    jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;String type;}
{/*@bgen(jjtree) FormalRestNode */
        try {
/*@egen*/
	<COMMA>
	type = Type()
	t = <ID>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	
	{jjtn000.setText(type + " " + t.image);}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void ReturnStatement()                     : {/*@bgen(jjtree) ReturnStatementNode */
  ReturnStatementNode jjtn000 = new ReturnStatementNode(JJTRETURNSTATEMENTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ReturnStatementNode */
        try {
/*@egen*/
	<RETURN>Exp()<SEMI>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

String Type() : {Token t;}
{
	LOOKAHEAD(2)<INT>	{return "int";}
	|<INT><LBRACK><RBRACK>	{return "int []";}
	|LOOKAHEAD(2)<DOUBLE>	{return "double";}
	|<DOUBLE><LBRACK><RBRACK> {return "double []";}
	|<BOOLEAN>	{return "boolean";}
	|t = <ID>{return t.image;}
}


void Exp() : {}
{
	LOOKAHEAD(AndExp())AndExp()
	|NewExp()
}

void NewExp() : {}
{
	<NEW>
	(<INT><LBRACK>Exp()<RBRACK>
	|<DOUBLE><LBRACK>Exp()<RBRACK>
	|<ID><LPAREN><RPAREN>)
}

void AndExp() : {}
{
	NotExp()(<AND>NotExp())*
}

void NotExp() : {}
{
	(<NOT>)?LessExp()
}

void LessExp() : {}
{
	AddExp()(<LT>AddExp())*
}

void AddExp() : {}
{
	MultiExp()((<PLUS>|<MINUS>)MultiExp())*
}

void MultiExp() : {}
{
	SignExp()(<MUL>SignExp())*
}

void SignExp() : {}
{
	(<MINUS>)?Element()
}

void Element() : {}
{
	<INTLITERAL>
	|<REALLITERAL>
	|<TRUE>
	|<FALSE>
	|IDExp()
	|<LPAREN>Exp()<RPAREN>
}

void IDExp() : {}
{
	//LOOKAHEAD(3)NewExp()<DOT><ID>(<LPAREN>ExpList()<RPAREN>)?
	//|LOOKAHEAD(2)<ID><DOT><LENGTH>
	//|<ID>
	(LOOKAHEAD(Object()<DOT>)Object()<DOT>)?
	<ID>
	(<LBRACK>Exp()<RBRACK>
	|<DOT><LENGTH>
	|<LPAREN>ExpList()<RPAREN>)?
}

void Object() : {}
{
	<THIS>
	|<ID>
	|<NEW><ID><LPAREN><RPAREN>
}

void ExpList() : {}
{
	(Exp()(ExpRest())*)?
}

void ExpRest() : {}
{
	<COMMA>Exp()
}